* 单例比较好处理
* 集群, 热点数据
** 主从副本模式
*** master-slave
*** 数据保存在单机上, 没法解决热点数据
** 切片模式集群
*** 解决热点数据问题
*** 切片规则
**** 简单hash: hash(key) % 3 => 不利于扩展, 需要重hash
**** 一致性hash算法: hash环, 定位, 顺时针归位, 便于就群扩展, 增减服务器只涉及两台机器
***** 数据倾斜问题:大部署数据存储在少量服务器上
****** 每个服务器虚拟成n个点
* 缓存穿透: 大量的穿透影响才比较大
** 保存空值:
*** 使用uuid可以绕过, 同时造成redis大量的无意义缓存
**** redis缓存淘汰策略: LRU,LFU
** 保存所有的mySQL存在的Id => 会使内存占用过大, 效率变低
*** 布隆过滤器:布隆算法
**** 通过错误率换区空间占用
**** 过滤器表示存在(存在会冲突), 它未必存在;过滤器表示不存在, 一定不存在
**** 具体算法 => 应该不是单个映射,使用多个hash函数映射
**** 应用: 2个 100亿url的文件求交集
*****
1. 使用hash将文件映射成n个小文件, 各个小文件进行对比
*****
2. 布隆映射到 bitMap 中 => 只是大概率交集
* 缓存雪崩: 同期过时
* 实现分布式锁的基础
** worker 单线程, 串行的
** 发布订阅, 阻塞队列
** 本地方法
*** setnx+timeout
** 异常
*** C1挂了:会产生死锁 => 设置timeout
*** C1拿到锁之后, C2做什么
****
1. 用IO发送setnx指令做自旋
****
2. 阻塞队列的发布订阅方式 + 超时(Client + redis) => 避免自旋
*** 没有挂, 但是执行时间超时了, 会导致锁数量增加
**** 需要增加线程增加timeout, c1正常执行的情况下, 需要增加timeout时间
*** 锁上加标识, UUID方式, 防止删除错误的锁
*** redis会挂掉
* redis集群
** 主从复制集群
*** HA高可用单点故障 => 哨兵是监控切换一个从变为主节点, 其它节点重新跟随的方式
*** 数据同步, 节点间数据全量
*** 速度 -> AP : [[CAP]] => 同步不精准
*** tradoff, 取舍 => 分布式锁, 就是一台redis实例
**** 把业务剥离
**** 运维:真服务器 => 冗余设备(电源/网卡)
**** 忽略拜占庭 => 会有一定的成本
*** 分布式在同一个物理数据中心完成
**** redis性能, 同主机和其他进程 10W以上
**** 同一物理局域网性能 4W
**** NAT, 云主机, K, Hqps, 网络性能消耗较大
** cluster模式
*** 分治, 分片, 容量, 压力, 瓶颈
*** 每个节点存储一部分数据
*** 不同的锁访问不同的节点
* redlock算法
** redis单机挂掉了
** redlock, 多机
*** 获得锁过半, 可以获得锁
*** 获得锁的数量增加, 而不是获得单个的锁
** 不是redis实现, client的实现算法
** 获得锁的数量都相同,